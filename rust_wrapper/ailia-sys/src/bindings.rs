/* automatically generated by rust-bindgen 0.63.0 */

pub const AILIA_USER_API_SUCCESS: u32 = 0;
pub const AILIA_USER_API_FAILED: i32 = -1;
pub const AILIA_FILE_CALLBACK_VERSION: u32 = 1;
pub const AILIA_STATUS_SUCCESS: u32 = 0;
pub const AILIA_STATUS_INVALID_ARGUMENT: i32 = -1;
pub const AILIA_STATUS_ERROR_FILE_API: i32 = -2;
pub const AILIA_STATUS_INVALID_VERSION: i32 = -3;
pub const AILIA_STATUS_BROKEN: i32 = -4;
pub const AILIA_STATUS_MEMORY_INSUFFICIENT: i32 = -5;
pub const AILIA_STATUS_THREAD_ERROR: i32 = -6;
pub const AILIA_STATUS_INVALID_STATE: i32 = -7;
pub const AILIA_STATUS_UNSUPPORT_NET: i32 = -9;
pub const AILIA_STATUS_INVALID_LAYER: i32 = -10;
pub const AILIA_STATUS_INVALID_PARAMINFO: i32 = -11;
pub const AILIA_STATUS_NOT_FOUND: i32 = -12;
pub const AILIA_STATUS_GPU_UNSUPPORT_LAYER: i32 = -13;
pub const AILIA_STATUS_GPU_ERROR: i32 = -14;
pub const AILIA_STATUS_UNIMPLEMENTED: i32 = -15;
pub const AILIA_STATUS_PERMISSION_DENIED: i32 = -16;
pub const AILIA_STATUS_EXPIRED: i32 = -17;
pub const AILIA_STATUS_UNSETTLED_SHAPE: i32 = -18;
pub const AILIA_STATUS_DATA_HIDDEN: i32 = -19;
pub const AILIA_STATUS_DATA_REMOVED: i32 = -19;
pub const AILIA_STATUS_LICENSE_NOT_FOUND: i32 = -20;
pub const AILIA_STATUS_LICENSE_BROKEN: i32 = -21;
pub const AILIA_STATUS_LICENSE_EXPIRED: i32 = -22;
pub const AILIA_STATUS_NDIMENSION_SHAPE: i32 = -23;
pub const AILIA_STATUS_OTHER_ERROR: i32 = -128;
pub const AILIA_SHAPE_VERSION: u32 = 1;
pub const AILIA_MULTITHREAD_AUTO: u32 = 0;
pub const AILIA_ENVIRONMENT_ID_AUTO: i32 = -1;
pub const AILIA_DATATYPE_UNDEFINED: u32 = 0;
pub const AILIA_DATATYPE_FLOAT: u32 = 1;
pub const AILIA_DATATYPE_UINT8: u32 = 2;
pub const AILIA_DATATYPE_INT8: u32 = 3;
pub const AILIA_DATATYPE_UINT16: u32 = 4;
pub const AILIA_DATATYPE_INT16: u32 = 5;
pub const AILIA_DATATYPE_INT32: u32 = 6;
pub const AILIA_DATATYPE_INT64: u32 = 7;
pub const AILIA_DATATYPE_BOOL: u32 = 9;
pub const AILIA_DATATYPE_FLOAT16: u32 = 10;
pub const AILIA_DATATYPE_DOUBLE: u32 = 11;
pub const AILIA_DATATYPE_UINT32: u32 = 12;
pub const AILIA_DATATYPE_UINT64: u32 = 13;
pub const AILIA_DATATYPE_BFLOAT16: u32 = 16;
pub const AILIA_ENVIRONMENT_VERSION: u32 = 2;
pub const AILIA_ENVIRONMENT_TYPE_CPU: u32 = 0;
pub const AILIA_ENVIRONMENT_TYPE_BLAS: u32 = 1;
pub const AILIA_ENVIRONMENT_TYPE_GPU: u32 = 2;
pub const AILIA_ENVIRONMENT_TYPE_REMOTE: u32 = 3;
pub const AILIA_ENVIRONMENT_BACKEND_NONE: u32 = 0;
pub const AILIA_ENVIRONMENT_BACKEND_CUDA: u32 = 2;
pub const AILIA_ENVIRONMENT_BACKEND_MPS: u32 = 3;
pub const AILIA_ENVIRONMENT_BACKEND_VULKAN: u32 = 6;
pub const AILIA_ENVIRONMENT_PROPERTY_NORMAL: u32 = 0;
pub const AILIA_ENVIRONMENT_PROPERTY_LOWPOWER: u32 = 1;
pub const AILIA_ENVIRONMENT_PROPERTY_FP16: u32 = 2;
pub const AILIA_MEMORY_NO_OPTIMIZATION: u32 = 0;
pub const AILIA_MEMORY_REDUCE_CONSTANT: u32 = 1;
pub const AILIA_MEMORY_REDUCE_CONSTANT_WITH_INPUT_INITIALIZER: u32 = 2;
pub const AILIA_MEMORY_REDUCE_INTERSTAGE: u32 = 4;
pub const AILIA_MEMORY_REUSE_INTERSTAGE: u32 = 8;
pub const AILIA_MEMORY_OPTIMAIZE_DEFAULT: u32 = 1;
pub const AILIA_PROFILE_DISABLE: u32 = 0;
pub const AILIA_PROFILE_AVERAGE: u32 = 1;
pub const AILIA_IMAGE_FORMAT_RGBA: u32 = 0;
pub const AILIA_IMAGE_FORMAT_BGRA: u32 = 1;
pub const AILIA_IMAGE_FORMAT_RGB: u32 = 2;
pub const AILIA_IMAGE_FORMAT_BGR: u32 = 3;
pub const AILIA_IMAGE_FORMAT_RGBA_B2T: u32 = 16;
pub const AILIA_IMAGE_FORMAT_BGRA_B2T: u32 = 17;
pub const AILIA_NETWORK_IMAGE_FORMAT_BGR: u32 = 0;
pub const AILIA_NETWORK_IMAGE_FORMAT_RGB: u32 = 1;
pub const AILIA_NETWORK_IMAGE_FORMAT_GRAY: u32 = 2;
pub const AILIA_NETWORK_IMAGE_FORMAT_GRAY_EQUALIZE: u32 = 3;
pub const AILIA_NETWORK_IMAGE_CHANNEL_FIRST: u32 = 0;
pub const AILIA_NETWORK_IMAGE_CHANNEL_LAST: u32 = 1;
pub const AILIA_NETWORK_IMAGE_RANGE_UNSIGNED_INT8: u32 = 0;
pub const AILIA_NETWORK_IMAGE_RANGE_SIGNED_INT8: u32 = 1;
pub const AILIA_NETWORK_IMAGE_RANGE_UNSIGNED_FP32: u32 = 2;
pub const AILIA_NETWORK_IMAGE_RANGE_SIGNED_FP32: u32 = 3;
pub const AILIA_NETWORK_IMAGE_RANGE_IMAGENET: u32 = 4;
pub const AILIA_DETECTOR_OBJECT_VERSION: u32 = 1;
pub const AILIA_DETECTOR_ALGORITHM_YOLOV1: u32 = 0;
pub const AILIA_DETECTOR_ALGORITHM_YOLOV2: u32 = 1;
pub const AILIA_DETECTOR_ALGORITHM_YOLOV3: u32 = 2;
pub const AILIA_DETECTOR_ALGORITHM_YOLOV4: u32 = 3;
pub const AILIA_DETECTOR_ALGORITHM_YOLOX: u32 = 4;
pub const AILIA_DETECTOR_ALGORITHM_SSD: u32 = 8;
pub const AILIA_DETECTOR_FLAG_NORMAL: u32 = 0;
pub const AILIA_CLASSIFIER_CLASS_VERSION: u32 = 1;
pub const AILIA_POSE_ESTIMATOR_ALGORITHM_ACCULUS_POSE: u32 = 0;
pub const AILIA_POSE_ESTIMATOR_ALGORITHM_ACCULUS_FACE: u32 = 1;
pub const AILIA_POSE_ESTIMATOR_ALGORITHM_ACCULUS_UPPOSE: u32 = 2;
pub const AILIA_POSE_ESTIMATOR_ALGORITHM_ACCULUS_UPPOSE_FPGA: u32 = 3;
pub const AILIA_POSE_ESTIMATOR_ALGORITHM_ACCULUS_HAND: u32 = 5;
pub const AILIA_POSE_ESTIMATOR_ALGORITHM_OPEN_POSE: u32 = 10;
pub const AILIA_POSE_ESTIMATOR_ALGORITHM_LW_HUMAN_POSE: u32 = 11;
pub const AILIA_POSE_ESTIMATOR_ALGORITHM_OPEN_POSE_SINGLE_SCALE: u32 = 12;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_NOSE: u32 = 0;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_EYE_LEFT: u32 = 1;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_EYE_RIGHT: u32 = 2;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_EAR_LEFT: u32 = 3;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_EAR_RIGHT: u32 = 4;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_SHOULDER_LEFT: u32 = 5;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_SHOULDER_RIGHT: u32 = 6;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_ELBOW_LEFT: u32 = 7;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_ELBOW_RIGHT: u32 = 8;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_WRIST_LEFT: u32 = 9;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_WRIST_RIGHT: u32 = 10;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_HIP_LEFT: u32 = 11;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_HIP_RIGHT: u32 = 12;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_KNEE_LEFT: u32 = 13;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_KNEE_RIGHT: u32 = 14;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_ANKLE_LEFT: u32 = 15;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_ANKLE_RIGHT: u32 = 16;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_SHOULDER_CENTER: u32 = 17;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_BODY_CENTER: u32 = 18;
pub const AILIA_POSE_ESTIMATOR_POSE_KEYPOINT_CNT: u32 = 19;
pub const AILIA_POSE_ESTIMATOR_FACE_KEYPOINT_CNT: u32 = 68;
pub const AILIA_POSE_ESTIMATOR_UPPOSE_KEYPOINT_NOSE: u32 = 0;
pub const AILIA_POSE_ESTIMATOR_UPPOSE_KEYPOINT_EYE_LEFT: u32 = 1;
pub const AILIA_POSE_ESTIMATOR_UPPOSE_KEYPOINT_EYE_RIGHT: u32 = 2;
pub const AILIA_POSE_ESTIMATOR_UPPOSE_KEYPOINT_EAR_LEFT: u32 = 3;
pub const AILIA_POSE_ESTIMATOR_UPPOSE_KEYPOINT_EAR_RIGHT: u32 = 4;
pub const AILIA_POSE_ESTIMATOR_UPPOSE_KEYPOINT_SHOULDER_LEFT: u32 = 5;
pub const AILIA_POSE_ESTIMATOR_UPPOSE_KEYPOINT_SHOULDER_RIGHT: u32 = 6;
pub const AILIA_POSE_ESTIMATOR_UPPOSE_KEYPOINT_ELBOW_LEFT: u32 = 7;
pub const AILIA_POSE_ESTIMATOR_UPPOSE_KEYPOINT_ELBOW_RIGHT: u32 = 8;
pub const AILIA_POSE_ESTIMATOR_UPPOSE_KEYPOINT_WRIST_LEFT: u32 = 9;
pub const AILIA_POSE_ESTIMATOR_UPPOSE_KEYPOINT_WRIST_RIGHT: u32 = 10;
pub const AILIA_POSE_ESTIMATOR_UPPOSE_KEYPOINT_HIP_LEFT: u32 = 11;
pub const AILIA_POSE_ESTIMATOR_UPPOSE_KEYPOINT_HIP_RIGHT: u32 = 12;
pub const AILIA_POSE_ESTIMATOR_UPPOSE_KEYPOINT_SHOULDER_CENTER: u32 = 13;
pub const AILIA_POSE_ESTIMATOR_UPPOSE_KEYPOINT_BODY_CENTER: u32 = 14;
pub const AILIA_POSE_ESTIMATOR_UPPOSE_KEYPOINT_CNT: u32 = 15;
pub const AILIA_POSE_ESTIMATOR_HAND_KEYPOINT_CNT: u32 = 21;
pub const AILIA_POSE_ESTIMATOR_OBJECT_POSE_VERSION: u32 = 1;
pub const AILIA_POSE_ESTIMATOR_OBJECT_FACE_VERSION: u32 = 1;
pub const AILIA_POSE_ESTIMATOR_OBJECT_UPPOSE_VERSION: u32 = 1;
pub const AILIA_POSE_ESTIMATOR_OBJECT_HAND_VERSION: u32 = 1;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
#[doc = " \\~japanese\n @brief ファイルを開きます\n @param const void *   ailiaOpenStreamEx() もしくは ailiaOpenWeightEx() に与えたfopen_args\n @return\n   成功した場合、ユーザ定義ファイルポインタを返す。\n   失敗した場合、NULLを返す。\n\n \\~english\n @brief Opens a file.\n @param const void *  fopen_args given to  ailiaOpenStreamEx()  or ailiaOpenWeightEx\n @return\n   This function returns a user-defined file pointer if successful.\n   It returns NULL if it fails."]
pub type AILIA_USER_API_FOPEN = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
#[doc = " \\~japanese\n @brief ファイルをシークします\n @param void *                     ユーザ定義ファイルポインタ\n @param  \\ref AILIA_FSIZE_RETURN_TYPE     ファイル先頭からのオフセットバイト\n @return\n   成功した場合、 \\ref AILIA_USER_API_SUCCESS を返す。\n   失敗した場合、 \\ref AILIA_USER_API_FAILED を返す。\n\n \\~english\n @brief It seeks the file specified.\n @param void *                     A user-defined file pointer\n @param  \\ref AILIA_FSIZE_RETURN_TYPE     Offset in bytes from the beginning of the file\n @return\n   This function returns  \\ref AILIA_USER_API_SUCCESS  if successful.\n   It returns  \\ref AILIA_USER_API_FAILED  if it fails."]
pub type AILIA_USER_API_FSEEK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " \\~japanese\n @brief ファイルの現在位置を取得します\n @param void * ユーザ定義ファイルポインタ\n @return\n   成功した場合、ファイルポインタの位置をバイト単位で返す。\n   失敗した場合、-1を返す。\n\n \\~english\n @brief Gets the current position in the file.\n @param void * A user-defined file pointer\n @return\n   This function returns the position, in bytes, the file pointer points to if successful.\n   It returns -1 if it fails."]
pub type AILIA_USER_API_FTELL = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_longlong,
>;
#[doc = " \\~japanese\n @brief ファイルのサイズを取得します\n @param void * ユーザ定義ファイルポインタ\n @return\n   成功した場合、ファイルのサイズをバイト単位で返す。\n   失敗した場合、-1を返す。\n\n \\~english\n @brief Gets the size of the file.\n @param void * A user-defined file pointer\n @return\n   This function returns the size of the file in bytes if successful.\n   It returns -1 if it fails."]
pub type AILIA_USER_API_FSIZE = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_longlong,
>;
#[doc = " \\~japanese\n @brief ファイルからデータを読み込みます\n @param void *                     読み込みデータ格納先のポインタ\n @param  \\ref AILIA_FSIZE_RETURN_TYPE     読み込みデータのバイト長さ\n @param void *                     ユーザ定義ファイルポインタ\n @return\n   成功した場合、 \\ref AILIA_USER_API_SUCCESS を返す。\n   失敗した場合、 \\ref AILIA_USER_API_FAILED を返す。\n   標準APIとは異なり、返値はAILIA_USER_API_*になりますのでご注意ください。\n\n \\~english\n @brief Reads data from the file.\n @param void *                     A pointer to the storage location of the data to be read\n @param  \\ref AILIA_FSIZE_RETURN_TYPE     The length in bytes of the data to be read\n @param void *                     A user-defined file pointer\n @return\n   This function returns  \\ref AILIA_USER_API_SUCCESS  if successful.\n   It returns  \\ref AILIA_USER_API_FAILED  if it fails.\n   Note that unlike the standard API, the return value will be AILIA_USER_API_*."]
pub type AILIA_USER_API_FREAD = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_longlong,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " \\~japanese\n @brief ファイルを閉じます\n @param void *  ユーザ定義ファイルポインタ\n @return\n   成功した場合、 \\ref AILIA_USER_API_SUCCESS を返す。\n   失敗した場合、 \\ref AILIA_USER_API_FAILED を返す。\n\n \\~english\n @brief Closes the file.\n @param void *  A user-defined file pointer\n @return\n   This function returns  \\ref AILIA_USER_API_SUCCESS  if successful.\n   It returns  \\ref AILIA_USER_API_FAILED  if it fails."]
pub type AILIA_USER_API_FCLOSE = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ailiaFileCallback {
    pub fopen: AILIA_USER_API_FOPEN,
    pub fseek: AILIA_USER_API_FSEEK,
    pub ftell: AILIA_USER_API_FTELL,
    pub fread: AILIA_USER_API_FREAD,
    pub fsize: AILIA_USER_API_FSIZE,
    pub fclose: AILIA_USER_API_FCLOSE,
}
#[test]
fn bindgen_test_layout__ailiaFileCallback() {
    const UNINIT: ::std::mem::MaybeUninit<_ailiaFileCallback> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ailiaFileCallback>(),
        48usize,
        concat!("Size of: ", stringify!(_ailiaFileCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<_ailiaFileCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(_ailiaFileCallback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fopen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ailiaFileCallback),
            "::",
            stringify!(fopen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fseek) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ailiaFileCallback),
            "::",
            stringify!(fseek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ftell) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ailiaFileCallback),
            "::",
            stringify!(ftell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fread) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ailiaFileCallback),
            "::",
            stringify!(fread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ailiaFileCallback),
            "::",
            stringify!(fsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fclose) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ailiaFileCallback),
            "::",
            stringify!(fclose)
        )
    );
}
pub type ailiaFileCallback = _ailiaFileCallback;
#[doc = " ネットワークオブジェクトのインスタンス"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILIANetwork {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AILIAShape {
    #[doc = " \\~japanese\n X軸のサイズ\n\n \\~english\n Size along the X axis"]
    pub x: ::std::os::raw::c_uint,
    #[doc = " \\~japanese\n Y軸のサイズ\n\n \\~english\n Size along the Y axis"]
    pub y: ::std::os::raw::c_uint,
    #[doc = " \\~japanese\n Z軸のサイズ\n\n \\~english\n Size along the Z axis"]
    pub z: ::std::os::raw::c_uint,
    #[doc = " \\~japanese\n W軸のサイズ\n\n \\~english\n Size along the W axis"]
    pub w: ::std::os::raw::c_uint,
    #[doc = " \\~japanese\n 次元情報\n\n \\~english\n Dimension information"]
    pub dim: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__AILIAShape() {
    const UNINIT: ::std::mem::MaybeUninit<_AILIAShape> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_AILIAShape>(),
        20usize,
        concat!("Size of: ", stringify!(_AILIAShape))
    );
    assert_eq!(
        ::std::mem::align_of::<_AILIAShape>(),
        4usize,
        concat!("Alignment of ", stringify!(_AILIAShape))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAShape),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAShape),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAShape),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAShape),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dim) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAShape),
            "::",
            stringify!(dim)
        )
    );
}
pub type AILIAShape = _AILIAShape;
extern "C" {
    #[doc = " \\~japanese\n @brief ネットワークオブジェクトを作成します。\n @param net ネットワークオブジェクトポインタへのポインタ\n @param env_id 計算に利用する推論実行環境のID( ailiaGetEnvironment() で取得)  \\ref AILIA_ENVIRONMENT_ID_AUTO\n にした場合は自動で選択する\n @param num_thread スレッド数の上限(  \\ref AILIA_MULTITHREAD_AUTO  にした場合は自動で設定)\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   ネットワークオブジェクトを作成します。\n   推論実行環境を自動にした場合はCPUモードになり、BLASが利用できる場合はBLASを利用します。\n   なお、BLASを利用する場合num_threadは無視される場合があります。\n\n \\~english\n @brief Creates a network instance.\n @param net A pointer to the network instance pointer\n @param env_id The ID of the inference backend used for computation (obtained by  ailiaGetEnvironment() ). It is\n selected automatically if  \\ref AILIA_ENVIRONMENT_ID_AUTO  is specified.\n @param num_thread The upper limit on the number of threads (It is set automatically if  \\ref AILIA_MULTITHREAD_AUTO\n is specified.)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   Creates a network instance.\n   If the inference backend is set to automatic, CPU mode is used, while if BLAS is available, it uses BLAS.\n   Note that if BLAS is used, num_thread may be ignored."]
    pub fn ailiaCreate(
        net: *mut *mut AILIANetwork,
        env_id: ::std::os::raw::c_int,
        num_thread: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief ネットワークオブジェクトを初期化します。(ファイルから読み込み)\n @param net ネットワークオブジェクトポインタ\n @param path prototxtファイルのパス名(MBSC or UTF16)\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   ファイルから読み込み、ネットワークオブジェクトを初期化します。\n\n \\~english\n @brief Initializes the network instance. (Read from file)\n @param net A network instance pointer\n @param path The path name to the prototxt file (MBSC or UTF16)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   This function reads the network instance from a file and initializes it."]
    pub fn ailiaOpenStreamFileA(
        net: *mut AILIANetwork,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ailiaOpenStreamFileW(
        net: *mut AILIANetwork,
        path: *const wchar_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief ネットワークオブジェクトを初期化します。(ユーザ定義ファイルアクセスコールバック)\n @param net ネットワークオブジェクトポインタ\n @param fopen_args  \\ref AILIA_USER_API_FOPEN に通知される引数ポインタ\n @param callback ユーザ定義ファイルアクセスコールバック関数構造体\n @param version ファイルアクセスコールバック関数構造体のバージョン( \\ref AILIA_FILE_CALLBACK_VERSION )\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   ファイルから読み込み、ネットワークオブジェクトを初期化します。\n\n \\~english\n @brief Initializes the network instance. (User-defined file access callback)\n @param net A network instance pointer\n @param fopen_args An argument pointer supplied by AILIA_USER_API_FOPEN\n @param callback A struct for the user-defined file access callback function\n @param version The version of the struct for the file access callback function ( \\ref AILIA_FILE_CALLBACK_VERSION )\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   This function reads the network instance from a file and initializes it."]
    pub fn ailiaOpenStreamEx(
        net: *mut AILIANetwork,
        fopen_args: *const ::std::os::raw::c_void,
        callback: ailiaFileCallback,
        version: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief ネットワークオブジェクトを初期化します。(メモリから読み込み)\n @param net ネットワークオブジェクトポインタ\n @param buf prototxtファイルのデータへのポインタ\n @param buf_size prototxtファイルのデータサイズ\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   メモリから読み込み、ネットワークオブジェクトを初期化します。\n\n \\~english\n @brief Initializes the network instance. (Read from memory)\n @param net A network instance pointer\n @param buf A pointer to the data in the prototxt file\n @param buf_size The data size of the prototxt file\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   This function reads the network instance from memory and initializes it."]
    pub fn ailiaOpenStreamMem(
        net: *mut AILIANetwork,
        buf: *const ::std::os::raw::c_void,
        buf_size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief ネットワークオブジェクトに重み係数を読み込みます。(ファイルから読み込み)\n @param net ネットワークオブジェクトポインタ\n @param path protobuf/onnxファイルのパス名(MBSC or UTF16)\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   ファイルからネットワークオブジェクトに重み係数を読み込みます。\n\n \\~english\n @brief Reads weights into a network instance. (Read from file)\n @param net A network instance pointer\n @param path The path name to the protobuf/onnx file (MBSC or UTF16)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   This function reads weights into the network instance from a file."]
    pub fn ailiaOpenWeightFileA(
        net: *mut AILIANetwork,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ailiaOpenWeightFileW(
        net: *mut AILIANetwork,
        path: *const wchar_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief ネットワークオブジェクトに重み係数を読み込みます。(ユーザ定義ファイルアクセスコールバック)\n @param net ネットワークオブジェクトポインタ\n @param fopen_args  \\ref AILIA_USER_API_FOPEN に通知される引数ポインタ\n @param callback ユーザ定義ファイルアクセスコールバック関数構造体\n @param version ファイルアクセスコールバック関数構造体のバージョン( \\ref AILIA_FILE_CALLBACK_VERSION )\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   ファイルからネットワークオブジェクトに重み係数を読み込みます。\n\n \\~english\n @brief Reads weights into a network instance. (User-defined file access callback)\n @param net A network instance pointer\n @param fopen_args An argument pointer supplied by AILIA_USER_API_FOPEN\n @param callback A struct for the user-defined file access callback function\n @param version The version of the struct for the file access callback function ( \\ref AILIA_FILE_CALLBACK_VERSION )\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   This function reads weights into the network instance from a file."]
    pub fn ailiaOpenWeightEx(
        net: *mut AILIANetwork,
        fopen_args: *const ::std::os::raw::c_void,
        callback: ailiaFileCallback,
        version: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief ネットワークオブジェクトに重み係数を読み込みます。(メモリから読み込み)\n @param net ネットワークオブジェクトポインタ\n @param buf protobuf/onnxファイルのデータへのポインタ\n @param buf_size protobuf/onnxファイルのデータサイズ\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   メモリからネットワークオブジェクトに重み係数を読み込みます。\n\n \\~english\n @brief Reads weights into a network instance. (Read from memory)\n @param net A network instance pointer\n @param buf A pointer to the data in the protobuf/onnx file\n @param buf_size The data size of the protobuf/onnx file\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   This function reads weights into the network instance from memory."]
    pub fn ailiaOpenWeightMem(
        net: *mut AILIANetwork,
        buf: *const ::std::os::raw::c_void,
        buf_size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief ネットワークオブジェクトを破棄します。\n @param net ネットワークオブジェクトポインタ\n\n \\~english\n @brief It destroys the network instance.\n @param net A network instance pointer"]
    pub fn ailiaDestroy(net: *mut AILIANetwork);
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時の入力データの形状を変更します。\n @param net ネットワークオブジェクトポインタ\n @param shape 入力データの形状情報\n @param version AILIA_SHAPE_VERSION\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   prototxtで定義されている入力形状を変更します。\n   prototxtに記述されているランクと同じにする必要があります。\n   なお、重み係数の形状が入力形状に依存しているなどによりエラーが返る場合があります。\n   prototxtで定義されているランクが4次元未満の場合は未使用の要素に1を設定する必要があります。\n   prototxtで定義されているランクが5次元以上の場合は ailiaSetInputShapeND() を利用してください。\n\n \\~english\n @brief Changes the shape of the input data during inference.\n @param net A network instance pointer\n @param shape Shape information for the input data\n @param version AILIA_SHAPE_VERSION\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   This function changes the input shape defined in prototxt.\n   The shape must have the same rank as the one contained in prototxt.\n   Note that an error may be returned if the weights are dependent on the input shapes, among other reasons.\n   The dimension of shape that defined in prototxt is less than 4, the unused element must be set to 1.\n   The dimension of shape that defined in prototxt has 5 or more, please use  ailiaSetInputShapeND() ()."]
    pub fn ailiaSetInputShape(
        net: *mut AILIANetwork,
        shape: *const AILIAShape,
        version: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時の入力データの形状を変更します。\n @param net ネットワークオブジェクトポインタ\n @param shape 入力データの各次元の大きさの配列(dim-1, dim-2, ... ,1, 0)\n @param dim shapeの次元\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   prototxtで定義されている入力形状を変更します。\n   prototxtに記述されているランクと同じにする必要があります。\n   なお、重み係数の形状が入力形状に依存しているなどによりエラーが返る場合があります。\n\n \\~english\n @brief Changes the shape of the input data during inference.\n @param net A network instance pointer\n @param shape An array of shape that contains size of each axis (dim-1, dim-2, ... ,1, 0)\n @param dim The size of shape.\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   This function changes the input shape defined in prototxt.\n   The shape must have the same rank as the one contained in prototxt.\n   Note that an error may be returned if the weights are dependent on the input shapes, among other reasons."]
    pub fn ailiaSetInputShapeND(
        net: *mut AILIANetwork,
        shape: *const ::std::os::raw::c_uint,
        dim: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時の入力データの形状を取得します。\n @param net ネットワークオブジェクトポインタ\n @param shape 入力データの形状情報\n @param version AILIA_SHAPE_VERSION\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、5次元以上の場合 \\ref AILIA_STATUS_NDIMENSION_SHAPE 、\n   形状の一部が未確定の場合 \\ref AILIA_STATUS_UNSETTLED_SHAPE 、それ以外のエラーの場合はエラーコードを返す。\n @details\n   形状が5次元以上の場合は ailiaGetInputDim() 、 ailiaGetInputShapeND() を利用してください。\n   形状の一部が未確定の場合、該当する次元の値は0となり、それ以外の次元の値は有効な値が格納されます。\n\n \\~english\n @brief Gets the shape of the input data during inference.\n @param net A network instance pointer\n @param shape Shape information for the input data\n @param version AILIA_SHAPE_VERSION\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS .\n   If shape has 5 or more dimension, it returns  \\ref AILIA_STATUS_NDIMENSION_SHAPE .\n   And if shape is not seattled, it returns \\ref AILIA_STATUS_UNSETTLED_SHAPE , or an error code otherwise.\n @details\n   When dimension of shape is 5 or more, please use  ailiaGetInputDim() and  ailiaGetInputShapeND().\n   When shape is not settled, this function stores 0 at unsettled dimension and otherwise stores valid value."]
    pub fn ailiaGetInputShape(
        net: *mut AILIANetwork,
        shape: *mut AILIAShape,
        version: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時の入力データの次元を取得します。\n @param net ネットワークオブジェクトポインタ\n @param dim 入力データの次元の格納先\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、それ以外のエラーの場合はエラーコードを返す。\n\n \\~english\n @brief Gets the dimension of the input data during inference.\n @param net A network instance pointer\n @param dim The storage location of the dimension\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaGetInputDim(
        net: *mut AILIANetwork,
        dim: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時の入力データの形状を取得します。\n @param net ネットワークオブジェクトポインタ\n @param shape 入力データの各次元の大きさの格納先配列(dim-1, dim-2, ... ,1, 0順で格納)\n @param dim shapeの次元\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、形状の一部が未確定の場合 \\ref AILIA_STATUS_UNSETTLED_SHAPE 、\n   それ以外のエラーの場合はエラーコードを返す。\n @details\n   形状の一部が未確定の場合、該当する次元の値は0となり、それ以外の次元の値は有効な値が格納されます。\n\n \\~english\n @brief Gets the shape of the input data during inference.\n @param net A network instance pointer\n @param shape The storage location of the shape array. (It stores dim-1, dim-2, ... ,1, 0 order.)\n @param dim The size of shape\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS .\n   And if shape is not seattled, it returns  \\ref AILIA_STATUS_UNSETTLED_SHAPE , or an error code otherwise.\n @details\n   When shape is not settled, this function stores 0 at unsettled dimension and otherwise stores valid value."]
    pub fn ailiaGetInputShapeND(
        net: *mut AILIANetwork,
        shape: *mut ::std::os::raw::c_uint,
        dim: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時の出力データの形状を取得します。\n @param net ネットワークオブジェクトポインタ\n @param shape 出力データの形状情報\n @param version AILIA_SHAPE_VERSION\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、5次元以上の場合 \\ref AILIA_STATUS_NDIMENSION_SHAPE 、\n   それ以外のエラーの場合エラーコードを返す。\n   形状が5次元以上の場合は ailiaGetOutputDim() 、 ailiaGetOutputShapeND() を利用してください。\n\n \\~english\n @brief Gets the shape of the output data during inference.\n @param net A network instance pointer\n @param shape Shape information of the output data\n @param version AILIA_SHAPE_VERSION\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS .\n   And if shape has 5 or more dimension, it returns  \\ref AILIA_STATUS_NDIMENSION_SHAPE , or an error code otherwise.\n @details\n   When dimension of shape is 5 or more, please use  ailiaGetOutputDim() () and  ailiaGetOutputShapeND() ()."]
    pub fn ailiaGetOutputShape(
        net: *mut AILIANetwork,
        shape: *mut AILIAShape,
        version: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時の出力データの次元を取得します。\n @param net ネットワークオブジェクトポインタ\n @param dim 出力データの次元の格納先\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、それ以外のエラーの場合はエラーコードを返す。\n\n \\~english\n @brief Gets the dimension of the output data during inference.\n @param net A network instance pointer\n @param dim The storage location of the dimension\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaGetOutputDim(
        net: *mut AILIANetwork,
        dim: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時の出力データの形状を取得します。\n @param net ネットワークオブジェクトポインタ\n @param shape 出力データの各次元の大きさの格納先配列(dim-1, dim-2, ... ,1, 0順で格納)\n @param dim shapeの次元\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、それ以外のエラーの場合はエラーコードを返す。\n\n \\~english\n @brief Gets the shape of the output data during inference.\n @param net A network instance pointer\n @param shape The storage location of the shape array. (It stores dim-1, dim-2, ... ,1, 0 order.)\n @param dim The size of shape\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaGetOutputShapeND(
        net: *mut AILIANetwork,
        shape: *mut ::std::os::raw::c_uint,
        dim: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論を行い推論結果を取得します。\n @param net ネットワークオブジェクトポインタ\n @param dest 推論結果の書き出し先バッファにX,Y,Z,Wの順でnumeric型で格納  サイズはネットファイルのoutputSizeとなる\n @param dest_size 推論結果の書き出し先バッファのbyte数\n @param src 推論データ X,Y,Z,Wの順でnumeric型で格納 サイズはネットファイルのinputSizeとなる\n @param src_size 推論データのbyte数\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Performs the inferences and provides the inference result.\n @param net A network instance pointer\n @param dest The result is stored in the inference result destination buffer as numeric type data in the order of X,\n Y, Z, and W. The buffer has the same size as the network file outputSize.\n @param dest_size The number of bytes for the destination buffer for the inference result\n @param src The input is stored as numeric type data in the order of the inference data X, Y, Z, and W. The input has\n the same size as the network file inputSize.\n @param src_size The number of bytes of the inference data\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaPredict(
        net: *mut AILIANetwork,
        dest: *mut ::std::os::raw::c_void,
        dest_size: ::std::os::raw::c_uint,
        src: *const ::std::os::raw::c_void,
        src_size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時の内部データ(Blob)の数を取得します。\n @param net ネットワークオブジェクトポインタ\n @param blob_count blobの数の格納先\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Gets the amount of internal data (blob) during inference.\n @param net A network instance pointer\n @param blob_count Storage location of the number of blobs\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaGetBlobCount(
        net: *mut AILIANetwork,
        blob_count: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時の内部データ(Blob)の形状を取得します。\n @param net ネットワークオブジェクトポインタ\n @param shape データの形状情報の格納先\n @param blob_idx blobのインデックス (0～ ailiaGetBlobCount() -1)\n @param version AILIA_SHAPE_VERSION\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、5次元以上の場合 \\ref AILIA_STATUS_NDIMENSION_SHAPE 、\n   それ以外のエラーの場合はエラーコードを返す。\n @details\n   形状が5次元以上の場合は ailiaGetBlobDim() 、 ailiaGetBlobShapeND() を利用してください。\n\n \\~english\n @brief Gets the shape of the internal data (blob) during inference.\n @param net A network instance pointer\n @param shape Storage location of the data shape information\n @param blob_idx The index of the blob (0 to  ailiaGetBlobCount() -1)\n @param version AILIA_SHAPE_VERSION\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS .\n   And if shape has 5 or more dimension, it returns  \\ref AILIA_STATUS_NDIMENSION_SHAPE , or an error code otherwise.\n @details\n   When dimension of shape is 5 or more, please use  ailiaGetBlobDim() and  ailiaGetBlobShapeND()."]
    pub fn ailiaGetBlobShape(
        net: *mut AILIANetwork,
        shape: *mut AILIAShape,
        blob_idx: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時の内部データ(Blob)の次元を取得します。\n @param net ネットワークオブジェクトポインタ\n @param dim blobの次元の格納先\n @param blob_idx blobのインデックス (0～ ailiaGetBlobCount() -1)\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、それ以外のエラーの場合はエラーコードを返す。\n\n \\~english\n @brief Gets the dimension of the internal data (blob) during inference.\n @param net A network instance pointer\n @param dim The storage location of the dimension\n @param blob_idx The index of the blob (0 to  ailiaGetBlobCount() -1)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaGetBlobDim(
        net: *mut AILIANetwork,
        dim: *mut ::std::os::raw::c_uint,
        blob_idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時の内部データ(Blob)の形状を取得します。\n @param net ネットワークオブジェクトポインタ\n @param shape blobの各次元の大きさの格納先配列(dim-1, dim-2, ... ,1, 0順で格納)\n @param dim shapeの次元\n @param blob_idx blobのインデックス (0～ ailiaGetBlobCount() -1)\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、それ以外のエラーの場合はエラーコードを返す。\n\n \\~english\n @brief Gets the amount of internal data (blob) during inference.\n @param net A network instance pointer\n @param shape The storage location of the shape array. (It stores dim-1, dim-2, ... ,1, 0 order.)\n @param dim The size of shape\n @param blob_idx The index of the blob (0 to  ailiaGetBlobCount() -1)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaGetBlobShapeND(
        net: *mut AILIANetwork,
        shape: *mut ::std::os::raw::c_uint,
        dim: ::std::os::raw::c_uint,
        blob_idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時の内部データ(Blob)を取得します。\n @param net ネットワークオブジェクトポインタ\n @param dest 推論結果の書き出し先バッファにX,Y,Z,Wの順でnumeric型で格納\n @param dest_size 推論結果の書き出し先バッファのbyte数\n @param blob_idx blobのインデックス (0～ ailiaGetBlobCount() -1)\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n    ailiaPredict() または ailiaUpdate() を一度も実行していない場合は \\ref AILIA_STATUS_INVALID_STATE が返ります。\n\n \\~english\n @brief Gets the internal data (blob) during inference.\n @param net A network instance pointer\n @param dest The result is stored in the inference result destination buffer as numeric type data in the order of X,\n Y, Z, and W.\n @param dest_size The number of bytes for the inference result destination buffer\n @param blob_idx The index of the blob (0 to  ailiaGetBlobCount() -1)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   If  ailiaPredict()  or  ailiaUpdate()  is not run at all, the function returns  \\ref AILIA_STATUS_INVALID_STATE ."]
    pub fn ailiaGetBlobData(
        net: *mut AILIANetwork,
        dest: *mut ::std::os::raw::c_void,
        dest_size: ::std::os::raw::c_uint,
        blob_idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時の内部データ(Blob)の型を取得します。\n @param net ネットワークオブジェクトポインタ\n @param type データ型の書き出し先バッファ。値は AILIA_DATATYPE_XXX で定義されています。\n @param blob_idx blobのインデックス (0～ ailiaGetBlobCount() -1)\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Get the type of Blob.\n @param net A network instance pointer\n @param blob_idx The index of the blob (0 to  ailiaGetBlobCount() -1)\n @param type The type of blob is stored to it. Values are defined as AILIA_DATATYPE_XXX.\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaGetBlobDataType(
        net: *mut AILIANetwork,
        type_: *mut ::std::os::raw::c_int,
        blob_idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時の内部データ(Blob)のインデックスを名前で探し取得します。\n @param net ネットワークオブジェクトポインタ\n @param blob_idx blobのインデックス (0～ ailiaGetBlobCount() -1)\n @param name 検索するBlob名\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Searches by name for the index of the internal data (blob) during inference and returns it.\n @param net A network instance pointer\n @param blob_idx The index of the blob (0 to  ailiaGetBlobCount() -1)\n @param name The name of the blob to search for\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaFindBlobIndexByName(
        net: *mut AILIANetwork,
        blob_idx: *mut ::std::os::raw::c_uint,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 内部データ(Blob)の名前の出力に必要なバッファのサイズを取得します。\n @param net ネットワークオブジェクトポインタ\n @param blob_idx blobのインデックス (0～ ailiaGetBlobCount() -1)\n @param buffer_size Blob名の出力に必要なバッファのサイズ(終端null文字分を含む)\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Gets the size of the buffer needed for output of the name of the internal data (blob).\n @param net A network instance pointer\n @param blob_idx The index of the blob (0 to  ailiaGetBlobCount() -1)\n @param buffer_size The size of the buffer needed for output of the blob name (including the null terminator)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaGetBlobNameLengthByIndex(
        net: *mut AILIANetwork,
        blob_idx: ::std::os::raw::c_uint,
        buffer_size: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時の内部データ(Blob)の名前をインデックスで探し取得します。\n @param net ネットワークオブジェクトポインタ\n @param buffer Blob名の出力先バッファ\n @param buffer_size バッファのサイズ(終端null文字分を含む)\n @param blob_idx 検索するblobのインデックス\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Searches by index for the name of the internal data (blob) during inference and returns it.\n @param net A network instance pointer\n @param buffer The output destination buffer for the blob name\n @param buffer_size The size of the buffer (including the null terminator)\n @param blob_idx The index of the blob to search for\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaFindBlobNameByIndex(
        net: *mut AILIANetwork,
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: ::std::os::raw::c_uint,
        blob_idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief ネットワークSummary用に必要なバッファのサイズを取得します。\n @param net ネットワークオブジェクトポインタ\n @param buffer_size バッファのサイズの格納先(終端null文字分を含む)\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Gets the size of the buffer needed for the network summary.\n @param net A network instance pointer\n @param buffer_size The storage location of the buffer size (including the null terminator)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaGetSummaryLength(
        net: *mut AILIANetwork,
        buffer_size: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 各Blobの名前と形状を表示します。\n @param net ネットワークオブジェクトポインタ\n @param buffer Summaryの出力先\n @param buffer_size 出力バッファのサイズ(終端null文字分を含む)。 ailiaGetSummaryLength()\n で取得した値を設定してください。\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Shows the name and shape of each blob.\n @param net A network instance pointer\n @param buffer The output destination of the summary\n @param buffer_size The size of the output buffer (including the null terminator). Set the value obtained by\n ailiaGetSummaryLength() .\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaSummary(
        net: *mut AILIANetwork,
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 入力データ(Blob)の数を取得します。\n @param net ネットワークオブジェクトポインタ\n @param input_blob_count 入力blobの数の格納先\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Get the number of input data blobs.\n @param net A network instance pointer\n @param input_blob_count Storage location of the number of input blobs\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaGetInputBlobCount(
        net: *mut AILIANetwork,
        input_blob_count: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 入力データ(Blob)のインデックスを取得します\n @param net ネットワークオブジェクトポインタ\n @param blob_idx blobのインデックス(0～ ailiaGetBlobCount() -1)\n @param input_blob_idx 入力blob内でのインデックス(0～ ailiaGetInputBlobCount() -1)\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Get the blob index of the input data.\n @param net A network instance pointer\n @param blob_idx index of the blob (between 0 and  ailiaGetBlobCount() -1)\n @param input_blob_idx index among the input blobs (between 0 and  ailiaGetInputBlobCount() -1)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaGetBlobIndexByInputIndex(
        net: *mut AILIANetwork,
        blob_idx: *mut ::std::os::raw::c_uint,
        input_blob_idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 指定したBlobに入力データを与えます。\n @param net ネットワークオブジェクトポインタ\n @param src 推論データ X,Y,Z,Wの順でnumeric型で格納\n @param src_size 推論データのbyte数\n @param blob_idx 入力するblobのインデックス\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   複数入力があるネットワークなどで入力を指定する場合に用います。\n   blob_idxで入力レイヤーのblob以外のものを指定した場合、 \\ref AILIA_STATUS_INVALID_ARGUMENT が返ります。\n\n \\~english\n @brief Provides the specified blob with the input data.\n @param net A network instance pointer\n @param src The inference data is stored as numeric type data in the order of X, Y, Z, and W.\n @param src_size The number of bytes of the inference data\n @param blob_idx The index of the blob for input\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   This function is used to specify the input on networks with multiple inputs.\n   If something other than a blob in the input layer is specified for blob_idx, the function returns  \\ref\n AILIA_STATUS_INVALID_ARGUMENT ."]
    pub fn ailiaSetInputBlobData(
        net: *mut AILIANetwork,
        src: *const ::std::os::raw::c_void,
        src_size: ::std::os::raw::c_uint,
        blob_idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 指定したBlobの形状を変更します。\n @param net ネットワークオブジェクトポインタ\n @param shape 入力データの形状情報\n @param blob_idx 変更するblobのインデックス\n @param version AILIA_SHAPE_VERSION\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   複数入力があるネットワークなどで入力形状を変更する場合に用います。\n   blob_idxは入力レイヤーのblob以外のものを指定した場合 \\ref AILIA_STATUS_INVALID_ARGUMENT が返ります。\n   その他の注意点は ailiaSetInputShape() の解説を参照してください。\n   入力形状のランクが5次元以上の場合は ailiaSetInputBlobShapeND() を利用してください。\n\n \\~english\n @brief Change the shape of the blob given by its index\n @param net network object pointer\n @param shape new shape of the blob\n @param blob_idx index referencing the blob to reshape\n @param version AILIA_SHAPE_VERSION\n @return\n   In case of success,  \\ref AILIA_STATUS_SUCCESS , and otherwise the coresponding error code.\n @details\n   This is useful to change the network input shape in a context where there are several input blobs.\n   If blob_idx does not correspond to an input layer,  \\ref AILIA_STATUS_INVALID_ARGUMENT  is returned.\n   For other related remarks, see the documentation of  ailiaSetInputShape().\n   If dimension of shape has 5 or more, please use  ailiaSetInputBlobShapeND()."]
    pub fn ailiaSetInputBlobShape(
        net: *mut AILIANetwork,
        shape: *const AILIAShape,
        blob_idx: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 指定したBlobの形状を変更します。\n @param net ネットワークオブジェクトポインタ\n @param shape 入力データの各次元の大きさの配列(dim-1, dim-2, ... ,1, 0)\n @param dim shapeの次元\n @param blob_idx 変更するblobのインデックス\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   複数入力があるネットワークなどで入力形状を変更する場合に用います。\n   blob_idxは入力レイヤーのblob以外のものを指定した場合 \\ref AILIA_STATUS_INVALID_ARGUMENT が返ります。\n   その他の注意点は ailiaSetInputShapeND() の解説を参照してください。\n\n \\~english\n @brief Change the shape of the blob given by its index\n @param net network object pointer\n @param shape An array of shape that contains size of each axis (dim-1, dim-2, ... ,1, 0)\n @param dim The size of shape.\n @param blob_idx index referencing the blob to reshape\n @return\n   In case of success,  \\ref AILIA_STATUS_SUCCESS , and otherwise the coresponding error code.\n @details\n   This is useful to change the network input shape in a context where there are several input blobs.\n   If blob_idx does not correspond to an input layer,  \\ref AILIA_STATUS_INVALID_ARGUMENT  is returned.\n   For other related remarks, see the documentation of  ailiaSetInputShapeND()."]
    pub fn ailiaSetInputBlobShapeND(
        net: *mut AILIANetwork,
        shape: *const ::std::os::raw::c_uint,
        dim: ::std::os::raw::c_uint,
        blob_idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 事前に指定した入力データで推論を行います。\n @param net ネットワークオブジェクトポインタ\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n    ailiaSetInputBlobData() を用いて入力を与えた場合などに用います。\n   推論結果は ailiaGetBlobData() で取得してください。\n\n \\~english\n @brief Makes inferences with the input data specified in advance.\n @param net A network instance pointer\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   This function is used when, for example, the input is provided with  ailiaSetInputBlobData() .\n   Get the inference result with  ailiaGetBlobData() ."]
    pub fn ailiaUpdate(net: *mut AILIANetwork) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 出力データ(Blob)の数を取得します。\n @param net ネットワークオブジェクトポインタ\n @param output_blob_count 出力blobの数の格納先\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Get the number of output data blobs.\n @param net A network instance pointer\n @param output_blob_count Storage location for the number of output blobs.\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaGetOutputBlobCount(
        net: *mut AILIANetwork,
        output_blob_count: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 出力データ(Blob)のインデックスを取得します\n @param net ネットワークオブジェクトポインタ\n @param blob_idx blobのインデックス(0～ ailiaGetBlobCount() -1)\n @param output_blob_idx 出力blob内でのインデックス(0～ ailiaGetOutputBlobCount() -1)\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Get the blob index of the input data blob.\n @param net A network instance pointer\n @param blob_idx blob index (between 0 and  ailiaGetBlobCount() -1)\n @param output_blob_idx index among output blobs (between 0 and  ailiaGetOutputBlobCount() -1)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaGetBlobIndexByOutputIndex(
        net: *mut AILIANetwork,
        blob_idx: *mut ::std::os::raw::c_uint,
        output_blob_idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AILIAEnvironment {
    #[doc = " \\~japanese\n 環境を識別するID( ailiaCreate() の引数に与える)\n\n \\~english\n The ID to identify the inference backend (passed to  ailiaCreate()  as an argument)"]
    pub id: ::std::os::raw::c_int,
    #[doc = " \\~japanese\n 環境の種別( \\ref AILIA_ENVIRONMENT_TYPE_CPU  or BLAS or GPU)\n\n \\~english\n The type of the inference backend ( \\ref AILIA_ENVIRONMENT_TYPE_CPU , BLAS, or GPU)"]
    pub type_: ::std::os::raw::c_int,
    #[doc = " \\~japanese\n デバイス名(シングルトンで保持されており開放不要)(ASCII)\n\n \\~english\n The device name. It is valid until the AILIANetwork instance is destroyed."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " \\~japanese\n 環境のバックエンド (AILIA_ENVIRONMENT_BACKEND_*)\n\n \\~english\n Computational (hardware) backend enabled by this environment (AILIA_ENVIRONMENT_BACKEND_*)"]
    pub backend: ::std::os::raw::c_int,
    #[doc = " \\~japanese\n 環境の特性などを示す(AILIA_ENVIRONMENT_PROPERTY_* の論理和)\n\n \\~english\n Additional property (low-power etc) of the environment (Logical-OR of AILIA_ENVIRONMENT_PROPERTY_*)"]
    pub props: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__AILIAEnvironment() {
    const UNINIT: ::std::mem::MaybeUninit<_AILIAEnvironment> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_AILIAEnvironment>(),
        24usize,
        concat!("Size of: ", stringify!(_AILIAEnvironment))
    );
    assert_eq!(
        ::std::mem::align_of::<_AILIAEnvironment>(),
        8usize,
        concat!("Alignment of ", stringify!(_AILIAEnvironment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAEnvironment),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAEnvironment),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAEnvironment),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backend) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAEnvironment),
            "::",
            stringify!(backend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).props) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAEnvironment),
            "::",
            stringify!(props)
        )
    );
}
pub type AILIAEnvironment = _AILIAEnvironment;
extern "C" {
    #[doc = " \\~japanese\n @brief 一時キャッシュディレクトリを指定します\n @param cache_dir 一時キャッシュディレクトリ\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   指定したキャッシュディレクトリは推論実行環境毎に最適化したマシンコードを生成して保存するためにシステムが利用します。\n   ailia の実行開始時に一度だけ呼び出してください。二回目以降の呼び出しに対しては無視して成功を返します。\n   複数スレッドから呼び出された場合も内部で排他制御しているので特に問題は発生しません。\n   Vulkan のシェーダーキャッシュ機能など、この API を呼ぶまで利用できないものがあります。\n   cache_dirにはContext.getCacheDir()で取得したファイルパスを指定してください。\n\n \\~english\n @brief Specifies a temporary cache directory.\n @param cache_dir Temporary cache directory\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   This system uses the specified cache directory to generate and store machine code optimized for each inference\n backend. Call only once at the start of execution of ailia. It ignores any second and subsequent calls, and\n automatically returns success. There is no particular problem if it is called from multiple threads, as it provides\n exclusive control internally. Some functions, such as Vulkan shader cache, cannot be used until this API function is\n called. Specify the file path obtained by Context.getCacheDir() for cache_dir."]
    pub fn ailiaSetTemporaryCachePathA(
        cache_dir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ailiaSetTemporaryCachePathW(cache_dir: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 利用可能な計算環境(CPU, GPU)の数を取得します\n @param env_count 計算環境情報の数の格納先\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Gets the number of available computational environments (CPU, GPU).\n @param env_count The storage location of the number of computational environment information\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaGetEnvironmentCount(
        env_count: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 計算環境の一覧を取得します\n @param env 計算環境情報の格納先(AILIANetworkインスタンスを破棄するまで有効)\n @param env_idx 計算環境情報のインデックス(0～ ailiaGetEnvironmentCount() -1)\n @param version AILIA_ENVIRONMENT_VERSION\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Gets the list of computational environments.\n @param env The storage location of the computational environment information (valid until the AILIANetwork instance\n is destroyed)\n @param env_idx The index of the computational environment information (0 to  ailiaGetEnvironmentCount() -1)\n @param version AILIA_ENVIRONMENT_VERSION\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaGetEnvironment(
        env: *mut *mut AILIAEnvironment,
        env_idx: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 選択された計算環境を取得します\n @param net ネットワークオブジェクトポインタ\n @param env 計算環境情報の格納先(AILIANetworkインスタンスを破棄するまで有効)\n @param version AILIA_ENVIRONMENT_VERSION\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Gets the selected computational environment.\n @param net A network instance pointer\n @param env The storage location of the computational environment information (valid until the AILIANetwork instance\n is destroyed)\n @param version AILIA_ENVIRONMENT_VERSION\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaGetSelectedEnvironment(
        net: *mut AILIANetwork,
        env: *mut *mut AILIAEnvironment,
        version: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時のメモリの使用方針を設定します\n @param net ネットワークオブジェクトポインタ\n @param mode メモリモード(論理和で複数指定可) AILIA_MEMORY_XXX (デフォルト: \\ref AILIA_MEMORY_REDUCE_CONSTANT )\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   メモリの使用方針を変更します。 \\ref AILIA_MEMORY_NO_OPTIMIZATION 以外を指定した場合は、\n   推論時に確保する中間バッファーを開放するため、推論時のメモリ使用量を削減することができます。\n    ailiaCreate() の直後に指定する必要があります。ailiaOpenを呼び出した後は変更することができません。\n   なお、中間バッファーを開放するように指定した場合、該当するBlobに対し、 ailiaGetBlobData() を呼び出すと\n    \\ref AILIA_STATUS_DATA_HIDDEN エラーが返ります。\n\n \\~english\n @brief Set the memory usage policy for inference\n @param net A network instance pointer\n @param mode Memory mode (Multiple specifications possible with logical sum) AILIA_MEMORY_XXX (Default : \\ref\n AILIA_MEMORY_REDUCE_CONSTANT )\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   Change the memory usage policy.\n   If a value other than  \\ref AILIA_MEMORY_NO_OPTIMIZATION  is specified,\n   the intermediate buffer secured during inference will be released, so the memory usage during inference can be\n reduced. Must be specified immediately after  ailiaCreate() . It cannot be changed after calling ailiaOpen. If you\n specify to release the intermediate buffer, calling  ailiaGetBlobData()  for the corresponding blob will return an\n \\ref AILIA_STATUS_DATA_HIDDEN  error."]
    pub fn ailiaSetMemoryMode(
        net: *mut AILIANetwork,
        mode: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 推論時のレイヤー統合を無効化します\n @param net ネットワークオブジェクトポインタ\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   レイヤー統合により取得できなくなるBlobを取得する必要がある場合などに用います。\n   ailiaCreate() の直後に指定する必要があります。ailiaOpenを呼び出した後は変更することができません。\n   なお、レイヤー統合を無効化すると推論速度が低下する場合があります。\n\n \\~english\n @brief Disalbe layer fusion optimaization for inference\n @param net A network instance pointer\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   This api use to get blob that remove by layer fusion optimization.\n   Must be specified immediately after  ailiaCreate() . It cannot be changed after calling ailiaOpen.\n   Note: When disable layer fusion optimization, inference speed may be down."]
    pub fn ailiaDisableLayerFusion(net: *mut AILIANetwork) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief プロファイルモードをセットします\n @param net          ネットワークオブジェクトポインタ\n @param mode         プロファイルモード\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   プロファイルモードを指定します。デフォルトは無効です。\n   ailiaOpenStreamXXXを呼び出したあとに呼び出してください。\n   プロファイルモードを有効にした場合、 ailiaSummary() の出力にプロファイル結果が追加されます。\n\n \\~english\n @brief Set the profile mode.\n @param net          The network instance pointer\n @param mode         Profile mode AILIA_PROFILE_XXX (Default : \\ref AILIA_PROFILE_DISABLE )\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   Set the profile mode. The default is profile disabled.\n   Call it after calling ailiaOpenStreamXXX.\n   When profile mode is enabled, you can get profile result via  ailiaSummary() ."]
    pub fn ailiaSetProfileMode(
        net: *mut AILIANetwork,
        mode: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief ステータスコードに対応する文字列を返します。\n @param status_code   ステータスコード\n @return\n   ステータスコードに対応する文字列。\n @details\n   返値は解放する必要はありません。\n   返された文字列は ailia のライブラリ(ailia.dll, libailia.so 等)をアンロードするまで有効です。\n   AILIANetwork のインスタンスがある場合は ailiaGetErrorDetail() でエラーの詳細を取得できます。\n\n \\~english\n @brief Returns the string describing given status code.\n @param status_code    Status code\n @return\n   String describing given status code.\n   Retuned string is valid until the library of ailia (ailia.dll, libailia.so, etc) is unloaded.\n @details\n   The return value does not have to be released.\n   If an instance of AILIANetwork is exist, ailiaGetErrorDetail() can be used to get the detail of the error."]
    pub fn ailiaGetStatusString(
        status_code: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\~japanese\n @brief エラーの詳細を返します\n @param net   ネットワークオブジェクトポインタ\n @return\n   エラー詳細\n @details\n   返値は解放する必要はありません。\n   文字列の有効期間は次にailiaのAPIを呼ぶまでです。\n   モデルが暗号化されている場合は空文字を返します。\n\n \\~english\n @brief Returns the details of errors.\n @param net   The network instance pointer\n @return\n   Error details\n @details\n   The return value does not have to be released.\n   The string is valid until the next ailia API function is called.\n   If model is encrypted, this function returns empty string."]
    pub fn ailiaGetErrorDetail(net: *mut AILIANetwork) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\~japanese\n @brief ライブラリバージョンを取得します\n @return\n   バージョン番号\n @details\n   返値は解放する必要はありません。\n\n \\~english\n @brief Get the version of the library.\n @return\n   Version number\n @details\n   The return value does not have to be released."]
    pub fn ailiaGetVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 画像のフォーマットを変換します。\n @param dst                  変換後画像の格納先(numeric型、sizeof(float) * dst_width * dst_height *\n チャンネル数(解説参照)以上のサイズを確保すること)\n @param dst_width            変換後画像の横幅\n @param dst_height           変換後画像の高さ\n @param dst_format           変換後画像の形式 (AILIA_NETWORK_IMAGE_FORMAT_*)\n @param dst_channel          変換後画像のチャンネル順 (AILIA_NETWORK_IMAGE_CHANNEL_*)\n @param dst_range            変換後画像のレンジ (AILIA_NETWORK_IMAGE_RANGE_*)\n @param src                  変換元画像の格納先(32bpp)\n @param src_stride           変換元画像のラインバイト数\n @param src_width            変換元画像の横幅\n @param src_height           変換元画像の高さ\n @param src_format           変換元画像の形式 (AILIA_IMAGE_FORMAT_*)\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   画像フォーマットを変更します。dst_formatが \\ref AILIA_NETWORK_IMAGE_FORMAT_BGR\n もしくはAILIA_NETWORK_IMAGE_FORMAT_RGB の場合、チャンネル数は3,  \\ref AILIA_NETWORK_IMAGE_FORMAT_GRAY\n の場合チャンネル数は1となります。\n\n \\~english\n @brief Converts image formats.\n @param dst                  The storage location of the image after conversion (numeric type; a size of sizeof(float)\n * dst_width * dst_height * num_of_channel(See Description) or more must be allocated.)\n @param dst_width            The width of the image after conversion\n @param dst_height           The height of the image after conversion\n @param dst_format           The format of the image after conversion (AILIA_NETWORK_IMAGE_FORMAT_*)\n @param dst_channel          The channel order of the image after conversion (AILIA_NETWORK_IMAGE_CHANNEL_*)\n @param dst_range            The range of the image after conversion (AILIA_NETWORK_IMAGE_RANGE_*)\n @param src                  The storage location of the source image (32 bpp)\n @param src_stride           The line byte number of the source image\n @param src_width            The width of the source image\n @param src_height           The height of the source image\n @param src_format           The format of the source image (AILIA_IMAGE_FORMAT_*)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   This function converts image formats. If dst_format is set to  \\ref AILIA_NETWORK_IMAGE_FORMAT_BGR  or  \\ref\n AILIA_NETWORK_IMAGE_FORMAT_RGB , the number of channels is 3, otherwise if set to  \\ref\n AILIA_NETWORK_IMAGE_FORMAT_GRAY , the number of channels is 1."]
    pub fn ailiaFormatConvert(
        dst: *mut ::std::os::raw::c_void,
        dst_width: ::std::os::raw::c_uint,
        dst_height: ::std::os::raw::c_uint,
        dst_format: ::std::os::raw::c_uint,
        dst_channel: ::std::os::raw::c_uint,
        dst_range: ::std::os::raw::c_uint,
        src: *const ::std::os::raw::c_void,
        src_stride: ::std::os::raw::c_int,
        src_width: ::std::os::raw::c_uint,
        src_height: ::std::os::raw::c_uint,
        src_format: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[doc = " 検出オブジェクトのインスタンス"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILIADetector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AILIADetectorObject {
    #[doc = " \\~japanese\n オブジェクトカテゴリ番号(0～category_count-1)\n\n \\~english\n Object category number (0 to category_count-1)"]
    pub category: ::std::os::raw::c_uint,
    #[doc = " \\~japanese\n 推定確率(0～1)\n\n \\~english\n Estimated probability (0 to 1)"]
    pub prob: f32,
    #[doc = " \\~japanese\n 左上X位置(1で画像幅)\n\n \\~english\n X position at the top left (1 for the image width)"]
    pub x: f32,
    #[doc = " \\~japanese\n 左上Y位置(1で画像高さ)\n\n \\~english\n Y position at the top left (1 for the image height)"]
    pub y: f32,
    #[doc = " \\~japanese\n 幅(1で画像横幅、負数は取らない)\n\n \\~english\n Width (1 for the width of the image, negative numbers not allowed)"]
    pub w: f32,
    #[doc = " \\~japanese\n 高さ(1で画像高さ、負数は取らない)\n\n \\~english\n Height (1 for the height of the image, negative numbers not allowed)"]
    pub h: f32,
}
#[test]
fn bindgen_test_layout__AILIADetectorObject() {
    const UNINIT: ::std::mem::MaybeUninit<_AILIADetectorObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_AILIADetectorObject>(),
        24usize,
        concat!("Size of: ", stringify!(_AILIADetectorObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_AILIADetectorObject>(),
        4usize,
        concat!("Alignment of ", stringify!(_AILIADetectorObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).category) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIADetectorObject),
            "::",
            stringify!(category)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prob) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIADetectorObject),
            "::",
            stringify!(prob)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIADetectorObject),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIADetectorObject),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIADetectorObject),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIADetectorObject),
            "::",
            stringify!(h)
        )
    );
}
pub type AILIADetectorObject = _AILIADetectorObject;
extern "C" {
    #[doc = " \\~japanese\n @brief 検出オブジェクトを作成します。\n @param detector       検出オブジェクトポインタ\n @param net            ネットワークオブジェクトポインタ\n @param format         ネットワークの画像フォーマット (AILIA_NETWORK_IMAGE_FORMAT_*)\n @param channel        ネットワークの画像チャンネル (AILIA_NETWORK_IMAGE_CHANNEL_*)\n @param range          ネットワークの画像レンジ (AILIA_NETWORK_IMAGE_RANGE_*)\n @param algorithm      検出アルゴリズム(AILIA_DETECTOR_ALGORITHM_*)\n @param category_count 検出カテゴリ数(VOCの場合は20、COCOの場合は80、などを指定)\n @param flags          追加オプションフラグ(AILIA_DETECTOR_FLAG_*)\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Creates a detector instance.\n @param detector       A detector instance pointer\n @param net            The network instance pointer\n @param format         The network image format (AILIA_NETWORK_IMAGE_FORMAT_*)\n @param channel        The network image channel (AILIA_NETWORK_IMAGE_CHANNEL_*)\n @param range          The network image range (AILIA_NETWORK_IMAGE_RANGE_*)\n @param algorithm      Detection algorithm(AILIA_DETECTOR_ALGORITHM_*)\n @param category_count The number of detection categories (specify 20 for VOC or 80 for COCO, etc.)\n @param flags          Additional option(AILIA_DETECTOR_FLAG_*)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaCreateDetector(
        detector: *mut *mut AILIADetector,
        net: *mut AILIANetwork,
        format: ::std::os::raw::c_uint,
        channel: ::std::os::raw::c_uint,
        range: ::std::os::raw::c_uint,
        algorithm: ::std::os::raw::c_uint,
        category_count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 検出オブジェクトを破棄します。\n @param detector 検出オブジェクトポインタ\n\n \\~english\n @brief Destroys the detector instance.\n @param detector A detector instance pointer"]
    pub fn ailiaDestroyDetector(detector: *mut AILIADetector);
}
extern "C" {
    #[doc = " \\~japanese\n @brief 物体検出を行います。\n @param detector                    検出オブジェクトポインタ\n @param src                         画像データ(32bpp)\n @param src_stride                  1ラインのバイト数\n @param src_width                   画像幅\n @param src_height                  画像高さ\n @param src_format                  画像フォーマット (AILIA_IMAGE_FORMAT_*)\n @param threshold                   検出しきい値(0.1f等)(小さいほど検出されやすくなり、検出数増加)\n @param iou                         重複除外しきい値(0.45f等)(小さいほど重複を許容せず検出数減少)\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Performs object detection.\n @param detector                    A detector instance pointer\n @param src                         Image data (32 bpp)\n @param src_stride                  The number of bytes in 1 line\n @param src_width                   Image width\n @param src_height                  Image height\n @param src_format                  Image format (AILIA_IMAGE_FORMAT_*)\n @param threshold                   The detection threshold (for example, 0.1f) (The smaller it is, the easier the\n detection will be and the more detected objects found.)\n @param iou                         Iou threshold (for example, 0.45f) (The smaller it is, the fewer detected objects\n found, as duplication is not allowed.)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaDetectorCompute(
        detector: *mut AILIADetector,
        src: *const ::std::os::raw::c_void,
        src_stride: ::std::os::raw::c_uint,
        src_width: ::std::os::raw::c_uint,
        src_height: ::std::os::raw::c_uint,
        src_format: ::std::os::raw::c_uint,
        threshold: f32,
        iou: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 検出結果の数を取得します。\n @param detector   検出オブジェクトポインタ\n @param obj_count  オブジェクト数\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Gets the number of detection results.\n @param detector   A detector instance pointer\n @param obj_count  The number of objects\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaDetectorGetObjectCount(
        detector: *mut AILIADetector,
        obj_count: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 検出結果を取得します。\n @param detector   検出オブジェクトポインタ\n @param obj        オブジェクト情報\n @param obj_idx    オブジェクトインデックス\n @param version    AILIA_DETECTOR_OBJECT_VERSION\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n    ailiaDetectorCompute() を一度も実行していない場合は \\ref AILIA_STATUS_INVALID_STATE が返ります。\n   検出結果は推定確率順でソートされます。\n\n \\~english\n @brief Gets the detection results.\n @param detector   A detector instance pointer\n @param obj        Object information\n @param obj_idx    Object index\n @param version    AILIA_DETECTOR_OBJECT_VERSION\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   If  ailiaDetectorCompute()  is not run at all, the function returns  \\ref AILIA_STATUS_INVALID_STATE .\n   The detection results are sorted in the order of estimated probability."]
    pub fn ailiaDetectorGetObject(
        detector: *mut AILIADetector,
        obj: *mut AILIADetectorObject,
        obj_idx: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief YoloV2などのためにアンカーズ (anchorsまたはbiases) の情報を設定します。\n @param detector       検出オブジェクトポインタ\n @param anchors        アンカーズの寸法 (検出ボックスの形状、高さと幅)\n @param anchors_count  アンカーズの数 (anchorsの配列サイズの半分)\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   YoloV2などは学習時に決定された複数の検出ボックスを使用して物体検出を行います。このAPIで学習時に決定された検出ボックスの形状を設定することで、正しい推論を行います。\n   anchorsには{x,y,x,y...}の形式で格納します。\n   anchors_countが5の場合、anchorsは10次元の配列になります。\n\n \\~english\n @brief Sets the anchor information (anchors or biases) for YoloV2 or other systems.\n @param detector       A detector instance pointer\n @param anchors        The anchor dimensions (the shape, height and width of the detection box)\n @param anchors_count  The number of anchors (half of the anchors array size)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   YoloV2 and other systems perform object detection with multiple detection boxes determined during training. By\n using this API function to set the shape of the detection box determined during training, correct inferences can be\n made. The {x, y, x, y ...} format is used for anchor storage. If anchors_count has a value of 5, then anchors is a\n 10-dimensional array."]
    pub fn ailiaDetectorSetAnchors(
        detector: *mut AILIADetector,
        anchors: *mut f32,
        anchors_count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief YoloV3またはYoloXでのモデルへの入力画像サイズを指定します。\n @param detector       検出オブジェクトポインタ\n @param input_width    モデルの入力画像幅\n @param input_height   モデルの入力画像高さ\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   YoloV3では単一のモデルが任意の入力解像度に対応します。(32 の倍数制限あり)\n   YoloXでは単一のモデルが任意の入力解像度に対応します。\n   計算量の削減等でモデルへの入力画像サイズを指定する場合この API を実行してください。\n    ailiaCreateDetector() () と  ailiaDetectorCompute() () の間に実行する必要があります。\n   この API を実行しない場合、デフォルトの 416x416 を利用します。\n   YOLOv3またはYOLOX 以外で実行した場合、 \\ref AILIA_STATUS_INVALID_STATE  を返します。\n\n \\~english\n @brief Sets the size of the input image for YoloV3 or YoloX model.\n @param detector       A detector instance pointer\n @param input_width    Width of the model's input image\n @param input_height   Height of the model's input image\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   The same YoloV3 model can be used for any input image size that is a multiple of 32.\n   The same YoloX model can be used for any input image size.\n   You can use this API if you want to choose the input image size, for example to reduce the calculation complexity.\n   It must be called between  ailiaCreateDetector() () and  ailiaDetectorCompute() ().\n   If this API is not used, a default size of 416x416 is assumed.\n   If used with some model other than YoloV3 or YoloX, it will return the error status  \\ref\n AILIA_STATUS_INVALID_STATE ."]
    pub fn ailiaDetectorSetInputShape(
        detector: *mut AILIADetector,
        input_width: ::std::os::raw::c_uint,
        input_height: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[doc = " 識別オブジェクトのインスタンス"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILIAClassifier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AILIAClassifierClass {
    #[doc = " \\~japanese\n 識別カテゴリ番号\n\n \\~english\n Classification category number"]
    pub category: ::std::os::raw::c_int,
    #[doc = " \\~japanese\n 推定確率(0～1)\n\n \\~english\n Estimated probability (0 to 1)"]
    pub prob: f32,
}
#[test]
fn bindgen_test_layout__AILIAClassifierClass() {
    const UNINIT: ::std::mem::MaybeUninit<_AILIAClassifierClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_AILIAClassifierClass>(),
        8usize,
        concat!("Size of: ", stringify!(_AILIAClassifierClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_AILIAClassifierClass>(),
        4usize,
        concat!("Alignment of ", stringify!(_AILIAClassifierClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).category) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAClassifierClass),
            "::",
            stringify!(category)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prob) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAClassifierClass),
            "::",
            stringify!(prob)
        )
    );
}
pub type AILIAClassifierClass = _AILIAClassifierClass;
extern "C" {
    #[doc = " \\~japanese\n @brief 識別オブジェクトを作成します。\n @param classifier 識別オブジェクトポインタへのポインタ\n @param net        ネットワークオブジェクトポインタ\n @param format     ネットワークの画像フォーマット （AILIA_NETWORK_IMAGE_FORMAT_*）\n @param channel    ネットワークの画像チャンネル (AILIA_NETWORK_IMAGE_CHANNEL_*)\n @param range      ネットワークの画像レンジ （AILIA_NETWORK_IMAGE_RANGE_*）\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Creates a classifier instance.\n @param classifier A pointer to a classifier instance pointer\n @param net        A network instance pointer\n @param format     The network image format (AILIA_NETWORK_IMAGE_FORMAT_*)\n @param channel    The network image channel (AILIA_NETWORK_IMAGE_CHANNEL_*)\n @param range      The network image range (AILIA_NETWORK_IMAGE_RANGE_*)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaCreateClassifier(
        classifier: *mut *mut AILIAClassifier,
        net: *mut AILIANetwork,
        format: ::std::os::raw::c_uint,
        channel: ::std::os::raw::c_uint,
        range: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 識別オブジェクトを破棄します。\n @param classifier 識別オブジェクトポインタ\n\n \\~english\n @brief Destroys the classifier instance.\n @param classifier A classifier instance pointer"]
    pub fn ailiaDestroyClassifier(classifier: *mut AILIAClassifier);
}
extern "C" {
    #[doc = " \\~japanese\n @brief 物体識別を行います。\n @param classifier                  識別オブジェクトポインタ\n @param src                         画像データ(32bpp)\n @param src_stride                  1ラインのバイト数\n @param src_width                   画像幅\n @param src_height                  画像高さ\n @param src_format                  画像のフォーマット (AILIA_IMAGE_FORMAT_*)\n @param max_class_count             識別結果の数の最大\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Performs object classification.\n @param classifier                  A classifier instance pointer\n @param src                         Image data (32 bpp)\n @param src_stride                  The number of bytes in 1 line\n @param src_width                   Image width\n @param src_height                  Image height\n @param src_format                  Image format (AILIA_IMAGE_FORMAT_*)\n @param max_class_count             The maximum number of classification results\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaClassifierCompute(
        classifier: *mut AILIAClassifier,
        src: *const ::std::os::raw::c_void,
        src_stride: ::std::os::raw::c_uint,
        src_width: ::std::os::raw::c_uint,
        src_height: ::std::os::raw::c_uint,
        src_format: ::std::os::raw::c_uint,
        max_class_count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 識別結果の数を取得します。\n @param classifier 識別オブジェクトポインタ\n @param cls_count  クラス数\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Gets the number of classification results.\n @param classifier A classifier instance pointer\n @param cls_count  The number of classes\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaClassifierGetClassCount(
        classifier: *mut AILIAClassifier,
        cls_count: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 識別結果を取得します。\n @param classifier 識別オブジェクトポインタ\n @param cls        クラス情報\n @param cls_idx    クラスインデックス\n @param version    \\ref AILIA_CLASSIFIER_CLASS_VERSION\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n    ailiaClassifierCompute() を一度も実行していない場合は \\ref AILIA_STATUS_INVALID_STATE が返ります。\n   識別結果は推定確率順でソートされます。\n\n \\~english\n @brief Gets the classification results.\n @param classifier A classifier instance pointer\n @param cls        Class information\n @param cls_idx    Class index\n @param version    \\ref AILIA_CLASSIFIER_CLASS_VERSION\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   If  ailiaClassifierCompute()  is not run at all, the function returns  \\ref AILIA_STATUS_INVALID_STATE .\n   The classification results are sorted in the order of estimated probability."]
    pub fn ailiaClassifierGetClass(
        classifier: *mut AILIAClassifier,
        obj: *mut AILIAClassifierClass,
        cls_idx: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[doc = " 検出オブジェクトのインスタンス"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AILIAPoseEstimator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AILIAPoseEstimatorKeypoint {
    #[doc = " \\~japanese\n 入力画像内 X座標  (0.0 , 1.0)\n\n \\~english\n Input image X coordinate (0.0, 1.0)"]
    pub x: f32,
    #[doc = " \\~japanese\n 入力画像内 Y座標  (0.0 , 1.0)\n\n \\~english\n Input image Y coordinate (0.0, 1.0)"]
    pub y: f32,
    #[doc = " \\~japanese\n 骨格検出のみ有効。体中心を座標0とした時に推定されるローカルZ座標。単位(スケール)は x と同じです。\n\n \\~english\n Valid only for human pose estimation. The local Z coordinate is estimated when the center of the body is defined\n as coordinate 0. The unit (scale) is the same as that for X."]
    pub z_local: f32,
    #[doc = " \\~japanese\n この点の検出信頼度。値が0.0Fの場合、この点は未検出のため使用できません。\n\n \\~english\n The confidence of this point. If the value is 0.0F, then this point is not available as it has not been detected\n yet."]
    pub score: f32,
    #[doc = " \\~japanese\n 通常は0です。この点が未検出で、他の点から補間可能な場合、x,yの値を補間し、interpolated=1となります。\n\n \\~english\n The default is 0. If this point has not been detected and can be interpolated by other points, the x and y values\n are then interpolated and the value of interpolated is set to 1."]
    pub interpolated: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__AILIAPoseEstimatorKeypoint() {
    const UNINIT: ::std::mem::MaybeUninit<_AILIAPoseEstimatorKeypoint> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_AILIAPoseEstimatorKeypoint>(),
        20usize,
        concat!("Size of: ", stringify!(_AILIAPoseEstimatorKeypoint))
    );
    assert_eq!(
        ::std::mem::align_of::<_AILIAPoseEstimatorKeypoint>(),
        4usize,
        concat!("Alignment of ", stringify!(_AILIAPoseEstimatorKeypoint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorKeypoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorKeypoint),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z_local) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorKeypoint),
            "::",
            stringify!(z_local)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).score) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorKeypoint),
            "::",
            stringify!(score)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interpolated) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorKeypoint),
            "::",
            stringify!(interpolated)
        )
    );
}
pub type AILIAPoseEstimatorKeypoint = _AILIAPoseEstimatorKeypoint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AILIAPoseEstimatorObjectPose {
    #[doc = " \\~japanese\n 検出した関節点。配列インデックスが関節番号に相当します。\n\n \\~english\n Detected body joint positions. The array index corresponding to a body joint number."]
    pub points: [AILIAPoseEstimatorKeypoint; 19usize],
    #[doc = " \\~japanese\n このオブジェクトの検出信頼度\n\n \\~english\n The confidence of this object"]
    pub total_score: f32,
    #[doc = " \\~japanese\n points[]の中で正常に検出された関節点の個数\n\n \\~english\n The number of body joint positions properly detected in points[]"]
    pub num_valid_points: ::std::os::raw::c_int,
    #[doc = " \\~japanese\n 時間方向に、このオブジェクトにユニークなIDです。1以上の正の値です。\n\n \\~english\n A unique ID for this object in the time direction. An integer value of 1 or more."]
    pub id: ::std::os::raw::c_int,
    #[doc = " \\~japanese\n このオブジェクトのオイラー角 yaw, pitch, roll\n [単位radian]。現在yawのみ対応しています。角度が検出されない場合FLT_MAXが格納されます。\n\n \\~english\n Euler angles for this object: yaw, pitch, and roll (in radians). Currently, only yaw is supported. If the angles\n are not detected, they are set to FLT_MAX."]
    pub angle: [f32; 3usize],
}
#[test]
fn bindgen_test_layout__AILIAPoseEstimatorObjectPose() {
    const UNINIT: ::std::mem::MaybeUninit<_AILIAPoseEstimatorObjectPose> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_AILIAPoseEstimatorObjectPose>(),
        404usize,
        concat!("Size of: ", stringify!(_AILIAPoseEstimatorObjectPose))
    );
    assert_eq!(
        ::std::mem::align_of::<_AILIAPoseEstimatorObjectPose>(),
        4usize,
        concat!("Alignment of ", stringify!(_AILIAPoseEstimatorObjectPose))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).points) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorObjectPose),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_score) as usize - ptr as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorObjectPose),
            "::",
            stringify!(total_score)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_valid_points) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorObjectPose),
            "::",
            stringify!(num_valid_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorObjectPose),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).angle) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorObjectPose),
            "::",
            stringify!(angle)
        )
    );
}
pub type AILIAPoseEstimatorObjectPose = _AILIAPoseEstimatorObjectPose;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AILIAPoseEstimatorObjectFace {
    #[doc = " \\~japanese\n 検出した顔特徴点。配列インデックスが顔特徴点番号に相当します。\n\n \\~english\n Detected human face landmarks. The array index corresponding to a human face landmark number."]
    pub points: [AILIAPoseEstimatorKeypoint; 68usize],
    #[doc = " \\~japanese\n このオブジェクトの検出信頼度\n\n \\~english\n The confidence of this object"]
    pub total_score: f32,
}
#[test]
fn bindgen_test_layout__AILIAPoseEstimatorObjectFace() {
    const UNINIT: ::std::mem::MaybeUninit<_AILIAPoseEstimatorObjectFace> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_AILIAPoseEstimatorObjectFace>(),
        1364usize,
        concat!("Size of: ", stringify!(_AILIAPoseEstimatorObjectFace))
    );
    assert_eq!(
        ::std::mem::align_of::<_AILIAPoseEstimatorObjectFace>(),
        4usize,
        concat!("Alignment of ", stringify!(_AILIAPoseEstimatorObjectFace))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).points) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorObjectFace),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_score) as usize - ptr as usize },
        1360usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorObjectFace),
            "::",
            stringify!(total_score)
        )
    );
}
pub type AILIAPoseEstimatorObjectFace = _AILIAPoseEstimatorObjectFace;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AILIAPoseEstimatorObjectUpPose {
    #[doc = " \\~japanese\n 検出した関節点。配列インデックスが関節番号に相当します。\n\n \\~english\n Detected body joint positions. The array index corresponding to a body joint number."]
    pub points: [AILIAPoseEstimatorKeypoint; 15usize],
    #[doc = " \\~japanese\n このオブジェクトの検出信頼度\n\n \\~english\n The confidence of this object"]
    pub total_score: f32,
    #[doc = " \\~japanese\n points[]の中で正常に検出された関節点の個数\n\n \\~english\n The number of body joint positions properly detected in points[]"]
    pub num_valid_points: ::std::os::raw::c_int,
    #[doc = " \\~japanese\n 時間方向に、このオブジェクトにユニークなIDです。1以上の正の値です。\n\n \\~english\n A unique ID for this object in the time direction. An integer value of 1 or more."]
    pub id: ::std::os::raw::c_int,
    #[doc = " \\~japanese\n このオブジェクトのオイラー角 yaw, pitch, roll\n [単位radian]。現在yawのみ対応しています。角度が検出されない場合FLT_MAXが格納されます。\n\n \\~english\n Euler angles for this object: yaw, pitch, and roll (in radians). Currently, only yaw is supported. If the angles\n are not detected, they are set to FLT_MAX."]
    pub angle: [f32; 3usize],
}
#[test]
fn bindgen_test_layout__AILIAPoseEstimatorObjectUpPose() {
    const UNINIT: ::std::mem::MaybeUninit<_AILIAPoseEstimatorObjectUpPose> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_AILIAPoseEstimatorObjectUpPose>(),
        324usize,
        concat!("Size of: ", stringify!(_AILIAPoseEstimatorObjectUpPose))
    );
    assert_eq!(
        ::std::mem::align_of::<_AILIAPoseEstimatorObjectUpPose>(),
        4usize,
        concat!("Alignment of ", stringify!(_AILIAPoseEstimatorObjectUpPose))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).points) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorObjectUpPose),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_score) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorObjectUpPose),
            "::",
            stringify!(total_score)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_valid_points) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorObjectUpPose),
            "::",
            stringify!(num_valid_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorObjectUpPose),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).angle) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorObjectUpPose),
            "::",
            stringify!(angle)
        )
    );
}
pub type AILIAPoseEstimatorObjectUpPose = _AILIAPoseEstimatorObjectUpPose;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AILIAPoseEstimatorObjectHand {
    #[doc = " \\~japanese\n 検出した関節点。配列インデックスが関節番号に相当します。\n\n \\~english\n Detected hand joint positions. The array index corresponding to a hand joint number."]
    pub points: [AILIAPoseEstimatorKeypoint; 21usize],
    #[doc = " \\~japanese\n このオブジェクトの検出信頼度\n\n \\~english\n The confidence of this object"]
    pub total_score: f32,
}
#[test]
fn bindgen_test_layout__AILIAPoseEstimatorObjectHand() {
    const UNINIT: ::std::mem::MaybeUninit<_AILIAPoseEstimatorObjectHand> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_AILIAPoseEstimatorObjectHand>(),
        424usize,
        concat!("Size of: ", stringify!(_AILIAPoseEstimatorObjectHand))
    );
    assert_eq!(
        ::std::mem::align_of::<_AILIAPoseEstimatorObjectHand>(),
        4usize,
        concat!("Alignment of ", stringify!(_AILIAPoseEstimatorObjectHand))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).points) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorObjectHand),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_score) as usize - ptr as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(_AILIAPoseEstimatorObjectHand),
            "::",
            stringify!(total_score)
        )
    );
}
pub type AILIAPoseEstimatorObjectHand = _AILIAPoseEstimatorObjectHand;
extern "C" {
    #[doc = " \\~japanese\n @brief 検出オブジェクトを作成します。\n @param pose_estimator 検出オブジェクトポインタ\n @param net            ネットワークオブジェクトポインタ\n @param algorithm      検出アルゴリズム (AILIA_POSE_ESTIMATOR_ALGORITHM_*)\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n @details\n   caffemodelとprototxtを読み込んだAILIANetworkから検出オブジェクトを作成します。\n\n \\~english\n @brief Creates a estimator instance.\n @param pose_estimator An estimator instance pointer\n @param net            The network instance pointer\n @param algorithm      Estimation algorithm(AILIA_POSE_ESTIMATOR_ALGORITHM_*)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise.\n @details\n   This function creates an estimator instance from AILIANetwork when reading caffemodel and prototxt."]
    pub fn ailiaCreatePoseEstimator(
        pose_estimator: *mut *mut AILIAPoseEstimator,
        net: *mut AILIANetwork,
        algorithm: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 検出オブジェクトを破棄します。\n @param pose_estimator 検出オブジェクトポインタ\n\n \\~english\n @brief Destroys the estimator instance.\n @param pose_estimator An estimator instance pointer"]
    pub fn ailiaDestroyPoseEstimator(pose_estimator: *mut AILIAPoseEstimator);
}
extern "C" {
    #[doc = " \\~japanese\n @brief 検出閾値を設定します。\n @param pose_estimator              検出オブジェクトポインタ\n @param threshold                   検出閾値 0.0以上1.0以下の値で、値が小さいほど検出しやすくなります。\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Set the detection threshold.\n @param pose_estimator              An estimator instance pointer\n @param threshold                   The detection threshold (for example, 0.1f) (The smaller it is, the easier the\n detection will be and the more detected objects found.)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaPoseEstimatorSetThreshold(
        pose_estimator: *mut AILIAPoseEstimator,
        threshold: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 骨格検出・顔特徴点検出を行います。\n @param pose_estimator              検出オブジェクトポインタ\n @param src                         画像データ(32bpp)\n @param src_stride                  1ラインのバイト数\n @param src_width                   画像幅\n @param src_height                  画像高さ\n @param src_format                  画像形式 (AILIA_IMAGE_FORMAT_*)\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Performs human pose estimation and human face landmarks extraction.\n @param pose_estimator              An estimator instance pointer\n @param src                         Image data (32 bpp)\n @param src_stride                  The number of bytes in 1 line\n @param src_width                   Image width\n @param src_height                  Image height\n @param src_format                  Image format (AILIA_IMAGE_FORMAT_*)\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaPoseEstimatorCompute(
        pose_estimator: *mut AILIAPoseEstimator,
        src: *const ::std::os::raw::c_void,
        src_stride: ::std::os::raw::c_uint,
        src_width: ::std::os::raw::c_uint,
        src_height: ::std::os::raw::c_uint,
        src_format: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 検出結果の数を取得します。\n @param pose_estimator  検出オブジェクトポインタ\n @param obj_count       オブジェクト数  顔特徴点の場合は1または0となります。\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Gets the number of detection results.\n @param pose_estimator  An estimator instance pointer\n @param obj_count       The number of objects. Set to 1 or 0 for human face landmarks.\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaPoseEstimatorGetObjectCount(
        pose_estimator: *mut AILIAPoseEstimator,
        obj_count: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 骨格検出結果を取得します。\n @param pose_estimator  検出オブジェクトポインタ\n @param obj             オブジェクト情報\n @param obj_idx         オブジェクトインデックス\n @param version         AILIA_POSE_ESTIMATOR_OBJECT_POSE_VERSION\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Gets the results of the human pose estimation.\n @param pose_estimator  An estimator instance pointer\n @param obj             Object information\n @param obj_idx         Object index\n @param version         AILIA_POSE_ESTIMATOR_OBJECT_POSE_VERSION\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaPoseEstimatorGetObjectPose(
        pose_estimator: *mut AILIAPoseEstimator,
        obj: *mut AILIAPoseEstimatorObjectPose,
        obj_idx: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief 顔特徴点検出結果を取得します。\n @param pose_estimator  検出オブジェクトポインタ\n @param obj             オブジェクト情報\n @param obj_idx         オブジェクトインデックス 必ず 0 を指定してください。\n @param version         AILIA_POSE_ESTIMATOR_OBJECT_FACE_VERSION\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Gets the results of the human face landmarks extraction.\n @param pose_estimator  An estimator instance pointer\n @param obj             Object information\n @param obj_idx         Object index. Ensure that 0 is specified.\n @param version         AILIA_POSE_ESTIMATOR_OBJECT_FACE_VERSION\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaPoseEstimatorGetObjectFace(
        pose_estimator: *mut AILIAPoseEstimator,
        obj: *mut AILIAPoseEstimatorObjectFace,
        obj_idx: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief UpPose 認識結果を取得します。\n @param pose_estimator  検出オブジェクトポインタ\n @param obj             オブジェクト情報\n @param obj_idx         オブジェクトインデックス\n @param version         AILIA_POSE_ESTIMATOR_OBJECT_POSE_VERSION\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Gets the results of the human up pose estimation.\n @param pose_estimator  An estimator instance pointer\n @param obj             Object information\n @param obj_idx         Object index\n @param version         AILIA_POSE_ESTIMATOR_OBJECT_UPPOSE_VERSION\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaPoseEstimatorGetObjectUpPose(
        pose_estimator: *mut AILIAPoseEstimator,
        obj: *mut AILIAPoseEstimatorObjectUpPose,
        obj_idx: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\~japanese\n @brief Hand 認識結果を取得します。\n @param pose_estimator  検出オブジェクトポインタ\n @param obj             オブジェクト情報\n @param obj_idx         オブジェクトインデックス 必ず 0 を指定してください。\n @param version         AILIA_POSE_ESTIMATOR_OBJECT_HAND_VERSION\n @return\n   成功した場合は \\ref AILIA_STATUS_SUCCESS 、そうでなければエラーコードを返す。\n\n \\~english\n @brief Gets the results of the human hand estimation.\n @param pose_estimator  An estimator instance pointer\n @param obj             Object information\n @param obj_idx         Object index. Ensure that 0 is specified.\n @param version         AILIA_POSE_ESTIMATOR_OBJECT_HAND_VERSION\n @return\n   If this function is successful, it returns  \\ref AILIA_STATUS_SUCCESS , or an error code otherwise."]
    pub fn ailiaPoseEstimatorGetObjectHand(
        pose_estimator: *mut AILIAPoseEstimator,
        obj: *mut AILIAPoseEstimatorObjectHand,
        obj_idx: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
